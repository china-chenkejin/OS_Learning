参考链接：
https://blog.csdn.net/kang___xi/article/details/80075223
互斥量和信号量的区别分析：https://blog.csdn.net/qq_34793133/article/details/80087727
介绍信号量、互斥量、临界区、事件的区别：https://blog.csdn.net/bao_qibiao/article/details/4516196

信号量可能会引起进程睡眠，开销较大，适用于保护较长的临界区；
信号量的缺点：
（1）Semaphore与Mutex在实现上有一个重大的区别：ownership。Mutex被持有后有一个明确的owner，而Semaphore并没有owner，当一个进程阻塞在某个信号量上时，它没法知道自己阻塞在哪个进程（线程）之上；
（2）没有ownership会带来以下几个问题：在保护临界区的时候，无法进行优先级反转的处理；系统无法对其进行跟踪断言处理，比如死锁检测等；信号量的调试变得更加麻烦

二元信号量。适合只能被唯一一个线程独占访问的资源。信号量的计数值为1，一次只允许一个进程进入临界区.

多元信号量。适合允许多个线程并发访问的资源。

互斥量/互斥锁
（1）和二元信号量类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另一个线程释放。而互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。
（2）互斥锁的缺点是互斥锁对象的结构较大，会占用更多的CPU缓存和内存空间；
（3）互斥锁是一种休眠锁，锁争用时可能存在进程的睡眠与唤醒，context的切换带来的代价较高，适用于加锁时间较长的场景；
（4）使用注意：一次只能有一个进程能持有互斥锁；只有锁的持有者能进行解锁操作；禁止多次解锁操作；禁止递归加锁操作；mutex结构只能通过API进行初始化；mutex结构禁止通过memset或者拷贝来进行初始化；已经被持有的mutex锁禁止被再次初始化；mutex不允许在硬件或软件上下文（tasklets, timer）中使用；
（5）当前linux内核的mutex中采用了 optimistic spinning 机制，使得互斥锁在锁竞争的时候不会立刻将进程或线程休眠，可以极大的提高性能

临界区。是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图去获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他的进程无法获取该锁。除此之外，临界区具有互斥量相同的性质。

读写信号量
（1）该信号量和读写锁类似，但是其可能导致进程或线程进入睡眠，增加切换开销
（2）为了优化读写信号量的性能，引入了MCS锁机制，进一步减少切换开销。第一个写者获取了锁后，第二个写者去获取时自旋等待，而读者去获取时则会进入睡眠

条件变量
参考链接：https://blog.csdn.net/erickhuang1989/article/details/8754357
https://zhuanlan.zhihu.com/p/55123862

在多线程程序中用来实现“等待->唤醒”逻辑常用的方法。


互斥量和自旋锁的选择原则：
（1）当锁不能被获取到时，使用互斥体的开销是进程上下文切换时间，使用自旋锁的开销是等
待获取自旋锁（由临界区执行时间决定）。若临界区比较小，宜使用自旋锁，若临界区很大，应
使用互斥体。

（2）互斥体所保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含
这样代码的临界区。因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一个进程企
图获取本自旋锁，死锁就会发生。

（3）互斥体存在于进程上下文，因此，如果被保护的共享资源需要在中断或软中断情况下使
用，则在互斥体和自旋锁之间只能选择自旋锁。当然，如果一定要使用互斥体，则只能通过mutex_trylock（）方式进行，不能获取就立即返回以避免阻塞。












